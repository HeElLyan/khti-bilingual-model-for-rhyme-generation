# -*- coding: utf-8 -*-
"""pronouncing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15HoHf9HpgpebhV0ut8kVW7x6VG0Cw7BQ
"""

from google.colab import drive
drive.mount('gdrive')

!pip install pronouncing

PATH = 'gdrive/My Drive/diploma/dataset/'

genres = ['rock', 'rap', 'pop', 'metal']

languages = ['eng', 'rus'

files_paths = [PATH + genre + '/' + 'test' for genre in genres]

files_paths_cross = [files_path + '_cross_' + language + '.txt' for files_path in files_paths for language in languages]
files_paths_circle = [files_path + '_circle_' + language + '.txt' for files_path in files_paths for language in languages]
files_paths_parallel = [files_path + '_parallel_' + language + '.txt' for files_path in files_paths for language in languages]

files_paths_cross_notpointercheck = [files_path + '_cross_' + language + '_notpointercheck.txt' for files_path in files_paths for language in languages]
files_paths_circle_notpointercheck = [files_path + '_circle_' + language + '_notpointercheck.txt' for files_path in files_paths for language in languages]
files_paths_parallel_notpointercheck = [files_path + '_parallel_' + language + '_notpointercheck.txt' for files_path in files_paths for language in languages]

files_paths_all = [files_paths_cross, files_paths_circle, files_paths_parallel]
files_paths_all_notpointercheck = [files_paths_cross_notpointercheck, files_paths_circle_notpointercheck, files_paths_parallel_notpointercheck]

files_paths_all, files_paths_all_notpointercheck

def get_focus_correct_words(data):
    last_focus_words = [item.split(' ')[-2] for item in data]
    correct_words = [item.split(' ')[-1] for item in data]
    return last_focus_words, correct_words

import pronouncing 

def get_rhymings(last_focus_words):

    all_rhymings_updated = []

    for last_focus_word in last_focus_words:

        loc_list = []

        for last_focus in last_focus_word:
            
            if len(pronouncing.phones_for_word(last_focus)) > 0:
              
                # get phone sound
                phones = pronouncing.phones_for_word(last_focus)[0]
                # get number of syllables
                syllables = pronouncing.syllable_count(phones)
                # get list of all rhymings
                rhymings = pronouncing.rhymes(last_focus)
                # print(rhymings)
                      
                # filter the rhymings based on last phone sound and number of syllables
                rhymings_updated = [rhyming for rhyming in rhymings if pronouncing.phones_for_word(rhyming)[0].split(" ")[-1]==phones.split(" ")[-1] and pronouncing.syllable_count(pronouncing.phones_for_word(rhyming)[0])==syllables]
                # print(rhymings_updated) 

                # use the target word in case no rhyming found
                if len(rhymings_updated) == 0:
                    rhymings_updated = [last_focus]
                    
            # use the target word if no phones found
            else:
                rhymings_updated = [last_focus]

            rhymings_updated = sorted(list(set(rhymings_updated)))

            loc_list.append(rhymings_updated)
            
        all_rhymings_updated.append(loc_list)

    return all_rhymings_updated

rules = ['cross', 'circle', 'parallel']
MAX_TEXT_LEN = len(max(rules))
MAX_TEXT_LEN

def get_title_step(MAX_NUM_LEN, genre):
    TITLE_STEP = ' ' * int((MAX_NUM_LEN - len(genre)) / 2)
    return TITLE_STEP

LEN_GENRES = len(genres)

def format_accuracy(accs):

    accs_str = [str(acc) for acc in accs]
    MAX_NUM_LEN = int(len(max(accs_str)))

    if len(accs) % LEN_GENRES == 0:

        print(' ' * (MAX_TEXT_LEN + 1) + ' '.join(get_title_step(MAX_NUM_LEN, genre) + genre + get_title_step(MAX_NUM_LEN + 2, genre) for genre in genres))

        cross = ' '.join([str(accs[i]) + ' ' * (MAX_NUM_LEN - len(str(accs[i]))) for i in range(LEN_GENRES)])
        circle = ' '.join([str(accs[i]) + ' ' * (MAX_NUM_LEN - len(str(accs[i]))) for i in range(LEN_GENRES, LEN_GENRES * 2)])
        parallel = ' '.join([str(accs[i]) + ' ' * (MAX_NUM_LEN - len(str(accs[i]))) for i in range(LEN_GENRES * 2, LEN_GENRES * 3)])

        cross_str = ' ' * (MAX_TEXT_LEN - len(rules[0])) + rules[0] + ' ' + cross
        circle_str = ' ' * (MAX_TEXT_LEN - len(rules[1])) + rules[1] + ' ' + circle
        parallel_str = ' ' * (MAX_TEXT_LEN - len(rules[2])) + rules[2] + ' ' + parallel

        print(cross_str)
        print(circle_str)
        print(parallel_str)

def count_acc(correct_words, rhymings):

    cor_pred = 0

    for i in range(len(rhymings)):
        for j in range(len(rhymings[i])):

            if correct_words[i] in rhymings[i][j]:
                cor_pred += 1

    acc = float(cor_pred / len(rhymings))

    return round(acc, 8)

import pickle

def count_acc_all_genres(files_paths_all):

    accs = []

    for files_path_all in files_paths_all:

        for files_path in files_path_all:

            print(files_path)
            
            with open(files_path, 'rb') as fp:
                data = pickle.load(fp)

            last_focus_words, correct_words = get_focus_correct_words(data)

            print(last_focus_words)
            print(correct_words)

            rhymings = get_rhymings(last_focus_words)
            acc = count_acc(correct_words, rhymings)
            print(acc)
            print()

            accs.append(acc)

    return accs

accs_notpointercheck = count_acc_all_genres(files_paths_all_notpointercheck)

format_accuracy(accs_notpointercheck)

accs = count_acc_all_genres(files_paths_all)

format_accuracy(accs)