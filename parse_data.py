# -*- coding: utf-8 -*-
"""parse_data.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eK70dBFrrHUkMkEo_tU89eiS8ATmW1XW
"""

from google.colab import drive
drive.mount('gdrive')

# Make HTTP requests
import requests
# Scrape data from an HTML document
from bs4 import BeautifulSoup
# I/O
import os
# Search and manipulate strings
import re

GENIUS_API_TOKEN = "p6NwZMkMdrWflUwtwGT-GoOkwh4colRTCT13iKE7IFiJcTOmi0-nh37AHh5ZsVdy"


# Get artist object from Genius API
def request_artist_info(artist_name, page):
    base_url = 'https://api.genius.com'
    headers = {'Authorization': 'Bearer ' + GENIUS_API_TOKEN}
    search_url = base_url + '/search?per_page=10&page=' + str(page)
    data = {'q': artist_name}
    response = requests.get(search_url, data=data, headers=headers)
    return response.json()


# Get Genius.com song url's from artist object
def request_song_url(artist_name, song_cap):
    page = 1
    songs = []
    
    while True:

        json = request_artist_info(artist_name, page)
        # json = response.json()
        
        # Collect up to song_cap song objects from artist
        song_info = []

        for hit in json['response']['hits']:
            if artist_name.lower() in hit['result']['primary_artist']['name'].lower():
                song_info.append(hit)
    
        # Collect song URL's from song objects
        for song in song_info:
            if (len(songs) < song_cap):
                url = song['result']['url']
                songs.append(url)
            
        if (len(songs) == song_cap):
            break
        else:
            page += 1
  
    print('Found {} songs by {}'.format(len(songs), artist_name))

    return songs

pointer = '[POINTER]'
new_line = ' \n '
rule = r'(?=[A-Z])'
rule_rus = r'(?=[А-Я])'

rule_brackets = r'\([^)]*\)'
rule_pointer = r'[\[].*?[]]'

RHYMING_NUM = 4

# Scrape lyrics from a Genius.com song URL
def scrape_song_lyrics(url):
    page = requests.get(url)

    html = BeautifulSoup(page.text, 'html.parser')

    try:
        lyrics = html.find('div', class_=re.compile("^lyrics$|Lyrics__Root")).get_text()

        lyrics = re.sub(r'[\".*?"]', '', lyrics)
        
        lyrics = re.sub(rule_brackets, '\n', lyrics)

        return lyrics
    except:
        return []

NOT_INFO = '«»&[]?.-;:!,'

def clean_and_split_lyrics(lyrics, pointerCheck=True):
    if lyrics == []:
        return lyrics

    #replace chorus and others with pointer
    lyrics = re.sub(rule_pointer, pointer, lyrics)
    lyrics = lyrics.strip(u'\u200b')
    lyrics = lyrics.strip(u'\u205f')

    #split lyrics by pointer(song parts)
    lyrics = lyrics.split(pointer)
    
    # remove the name of the song
    lyrics.pop(0)

    #remove unnecessary info like .,?![]
    for i in range(len(lyrics)):
        for item in NOT_INFO:
            lyrics[i] = lyrics[i].replace(item, '')

    #split lyrics to words in song parts
    lyrics_splitted = []
        
    for part in lyrics:

        if part == '':
            continue

        res = part.split(' ')

        lyrics_splitted.append(res)
        
    #remove info with the number of embeds
    del lyrics_splitted[-1][-1]

    cleaned_lyrics = []

    for part in lyrics_splitted:

        loc_list = ''

        for word in part:

            #get words that ends with uppercase(rule)
            if re.compile(rule).search(word):
                loc_res = re.split(rule, word)
                # print(loc_res)
            else:
                loc_res = re.split(rule_rus, word)
                # print(loc_res)

            #remove words with '' from list
            if loc_res[0] == '':
                loc_res.remove('')
                
            if len(loc_res) == 0:
                continue

            if len(loc_res) > 1:
                loc_res = [loc_res[0] + new_line + loc_res[1]]

            loc_list += loc_res[0] + ' '

        #remove duplicate \n
        loc_list = loc_list.replace(' \n \n ', '\n').strip()

        #split parts by sentences
        loc_list = loc_list.split('\n')

        #remove spaces
        loc_list = [item.strip() for item in loc_list]

        #remove empty sentences
        loc_list = [item for item in loc_list if item != '']

        if pointerCheck:        
            #search lines that % to 4(4,8 and etc) and split them by 4 pairs
            if len(loc_list) % RHYMING_NUM == 0:
                
                for i in range(0, len(loc_list), 4):
                    res = [loc_list[i], loc_list[i + 1], loc_list[i + 2], loc_list[i + 3]]
                    cleaned_lyrics.append(res)

            elif len(loc_list) > RHYMING_NUM:
                
                for i in range(0, len(loc_list) - 4):
                    res = [loc_list[i], loc_list[i + 1], loc_list[i + 2], loc_list[i + 3]]
                    cleaned_lyrics.append(res)
            
            else: 
                continue
        else:
            cleaned_lyrics += loc_list
    
    if not pointerCheck:

        cleaned_lyrics_copy = []

        for i in range(0, len(cleaned_lyrics) - 4):
            res = [cleaned_lyrics[i], cleaned_lyrics[i + 1], cleaned_lyrics[i + 2], cleaned_lyrics[i + 3]]
            cleaned_lyrics_copy.append(res)

        cleaned_lyrics = cleaned_lyrics_copy
      
    return cleaned_lyrics

PATH = 'gdrive/My Drive/diploma/dataset/'

import os.path
from os import path

def get_folder_path(genre, rule):

    folder_name = PATH + genre + '/' + rule

    return folder_name

def create_folder(folder_name):
    #create a folder
    if path.exists(folder_name) == False:
        os.mkdir(folder_name)

def collect_lyrics(artist_name, song_count, genre, pointerCheck = True):

    urls = request_song_url(artist_name, song_count)

    all_num_lines = 0

    all_artist_lyrics = []

    for i, url in enumerate(urls):
        
        lyrics = scrape_song_lyrics(url)

        if lyrics == []:
            if (i + 1) % 10 == 0:
                print('Got {} lines from {} songs'.format(all_num_lines, str(i + 1)))
            continue

        #check if lyrics have [Verse] and other pointers
        if check_pointer(lyrics):

            lyrics = clean_and_split_lyrics(lyrics,  pointerCheck = pointerCheck)
            
            all_artist_lyrics.append(lyrics)

            all_num_lines += len(lyrics)

        if (i + 1) % 10 == 0:
            print('Got {} lines from {} songs'.format(all_num_lines, str(i + 1)))

    return all_artist_lyrics, all_num_lines

def remove_duplicate(pairs_list):

    pairs = pairs_list.copy()

    for i in range(1, len(pairs_list) - 1, 2):

        if pairs_list[i] == pairs_list[i + 1] or pairs_list[i] == pairs_list[i - 1]:
            pairs.remove(pairs_list[i])

    return pairs

def split_lyrics_by_rule(artist_name, song_count, genre, pointerCheck = True):

    lyrics, _ = collect_lyrics(artist_name, song_count, genre, pointerCheck = pointerCheck)
    
    #create cross/circle/parallel folders
    folder_name = get_folder_path(genre, rule)

    lyrics = [part for lyric in lyrics for part in lyric]

    pairs_list_cross, pairs_list_circle, pairs_list_parallel = [], [], []

    for i in range(len(lyrics)):

        for j in range(0, len(lyrics[i]) - 3):

            pairs_list_cross.append(lyrics[i][j] + ' ' + lyrics[i][j + 2].split(' ')[-1])
            pairs_list_cross.append(lyrics[i][j + 1] + ' ' + lyrics[i][j + 3].split(' ')[-1])

            pairs_list_circle.append(lyrics[i][j] + ' ' + lyrics[i][j + 3].split(' ')[-1])
            pairs_list_circle.append(lyrics[i][j + 1] + ' ' + lyrics[i][j + 2].split(' ')[-1])

            pairs_list_parallel.append(lyrics[i][j] + ' ' + lyrics[i][j + 1].split(' ')[-1])
            pairs_list_parallel.append(lyrics[i][j + 2] + ' ' + lyrics[i][j + 3].split(' ')[-1])

    pairs_list_cross = remove_duplicate(pairs_list_cross)
    all_num_lines_cross = int(len(pairs_list_cross) / 2)

    pairs_list_circle = remove_duplicate(pairs_list_circle)
    all_num_lines_circle = int(len(pairs_list_circle) / 2)

    pairs_list_parallel = remove_duplicate(pairs_list_parallel)
    all_num_lines_parallel = int(len(pairs_list_parallel) / 2)

    pairs_list = [pairs_list_cross, pairs_list_circle, pairs_list_parallel]
    all_num_lines = [all_num_lines_cross, all_num_lines_circle, all_num_lines_parallel]

    return pairs_list, all_num_lines, folder_name

def collect_artists(artists, song_count, genre, pointerCheck=True):

    all_lyrics_cross, all_lyrics_circle, all_lyrics_parallel = [], [], []

    all_num_lines_cross, all_num_lines_circle, all_num_lines_parallel = 0, 0, 0

    for artist in artists:

        pairs_list, num_lines_list, _ = split_lyrics_by_rule(artist, song_count, genre, pointerCheck=pointerCheck)

        all_lyrics_cross += pairs_list[0]
        all_num_lines_cross += num_lines_list[0]

        all_lyrics_circle += pairs_list[1]
        all_num_lines_circle += num_lines_list[1]

        all_lyrics_parallel += pairs_list[2]
        all_num_lines_parallel += num_lines_list[2]

    all_lyrics = [all_lyrics_cross, all_lyrics_circle, all_lyrics_parallel]
    all_num_lines = [all_num_lines_cross, all_num_lines_circle, all_num_lines_parallel]

    return all_lyrics, all_num_lines

def split_to_train_test_val(lyrics):
    train = lyrics[int(len(lyrics) * 0) : int(len(lyrics) * .8)]
    test = lyrics[int(len(lyrics) * .8) : int(len(lyrics) * .9)]
    val = lyrics[int(len(lyrics) * .9) : int(len(lyrics) * 1)]
    return [train, test, val]

import pickle
import numpy as np
import pandas as pd

data_names = ['train', 'test', 'val']
rules = ['cross', 'circle', 'parallel']

def save_genre_to_file(artists, song_count, genre, language, pointerCheck=True):

    pairs_rules_list, num_lines_rules_list = collect_artists(artists, song_count, genre, pointerCheck=pointerCheck)

    data_list_cross = split_to_train_test_val(pairs_rules_list[0])
    data_list_circle = split_to_train_test_val(pairs_rules_list[1])
    data_list_parallel = split_to_train_test_val(pairs_rules_list[2])

    len_list_cross = [len(data_list_cross[0]), len(data_list_cross[1]), len(data_list_cross[2])]
    print('cross = ', len_list_cross)

    len_list_circle = [len(data_list_circle[0]), len(data_list_circle[1]), len(data_list_circle[2])]
    print('cricle = ', len_list_circle)

    len_list_parallel = [len(data_list_parallel[0]), len(data_list_parallel[1]), len(data_list_parallel[2])]
    print('parallel = ', len_list_parallel)
    
    data_list = [data_list_cross, data_list_circle, data_list_parallel]
    len_list = [len_list_cross, len_list_circle, len_list_parallel]
    
    for i, rule in enumerate(rules):

        for j, name in enumerate(data_names):

            if not pointerCheck:
                loc_path = PATH + genre + '/' + name + '_' + rule + '_' + language + '_' + 'notpointercheck' + '.txt'
            else:
                loc_path = PATH + genre + '/' + name + '_' + rule + '_' + language + '.txt'

            with open(loc_path, 'wb') as fp:
                pickle.dump(data_list[i][j], fp)
        
            print('Wrote {} paired lines to a file {}'.format(len_list[i][j], loc_path))

eng_rock_artists = ['led zeppelin', 'queen', 'pink floyd', 'the beatles', 'black sabbath', 'the rolling stones', 'iron maiden', 'deep purple', 'the who', 'van halen', 'kiss', 'aerosmith', 'eagles', 'the beach boys', 'the doors', 'nirvana']
eng_rap_artists = ['drake', 'outkast', 'travis scott', 'snoop dogg', 'lil wayne', '50 cent', 'kendrick lamar', 'eminem', 'jay-z', '2pac']
eng_pop_artists = ['dua lipa', 'taylor swift', 'ariana grande', 'billie eilish', 'adele', 'lady gaga', 'khalid', 'halsey', 'ed sheeran', 'alicia keys', 'avril lavigne', 'lana del rey']
eng_metal_artists = ['periphery', 'veil of maya', 'memphis may fire', 'architects', 'bullet for my valentine', 'bring me the horizon', 'northlane', 'arch enemy', 'system of a down', 'jinjer', 'slipknot', 'korn', 'linkin park', 'dance gavin dance', 'while she sleeps']
print(len(eng_rock_artists), len(eng_rap_artists), len(eng_pop_artists), len(eng_metal_artists))
eng_genres_artists = [eng_rock_artists, eng_rap_artists, eng_pop_artists, eng_metal_artists]

SONGS_NUM_DEFAULT = 50
SONGS_NUM_MIDDLE = 75
SONGS_NUM_MAX = 100

genres = ['rock', 'rap', 'pop']

#english dataset
for i, genre in enumerate(genres):
    print(genre)
    print('##################################')
    save_genre_to_file(eng_genres_artists[i], SONGS_NUM_DEFAULT, genre, 'eng')

#english dataset
for i, genre in enumerate(genres):
    print(genre)
    print('##################################')
    save_genre_to_file(eng_genres_artists[i], SONGS_NUM_DEFAULT, genre, 'eng', pointerCheck=False)

#english dataset metal
print('metal')
print('##################################')
save_genre_to_file(eng_metal_artists, SONGS_NUM_DEFAULT, 'metal', 'eng')
save_genre_to_file(eng_metal_artists, SONGS_NUM_DEFAULT, 'metal', 'eng', pointerCheck=False)

rus_rock_artists = ['король и шут', 'мумий тролль', 'кино', 'ленинград',  'ддт', 'гражданская оборона', 'би-2', 'сплин', 'lumen', 'аквариум']
rus_rap_artists = ['oxxxymiron', 'каста', 'баста', 'guf', 'макс корж', 'тимати','скриптонит', 'anacondaz']
rus_pop_artists = ['басков', 'дискотека авария', 'григорий лепс', 'дима билан', 'валерия', 'филипп киркоров', 'сергей лазарев', 'винтаж']
rus_metal_artists = ['aria', 'amatory', 'stigmata', 'wildways']
print(len(rus_rock_artists), len(rus_rap_artists), len(rus_pop_artists), len(rus_metal_artists))
rus_genres_artists = [rus_rock_artists, rus_rap_artists, rus_pop_artists, rus_metal_artists]

russian dataset
for genre in enumerate(genres[:1]):
    print(genre)
    print('##################################')
    save_genre_to_file(rus_genres_artists[0], SONGS_NUM_MAX, genre, 'rus')

for genre in genres[1:2]:
    print(genre)
    print('##################################')
    save_genre_to_file(rus_genres_artists[1], SONGS_NUM_MAX, genre, 'rus')

for genre in genres[2:len(genres)]:
    print(genre)
    print('##################################')
    save_genre_to_file(rus_genres_artists[2], SONGS_NUM_MIDDLE, genre, 'rus')

#russian dataset
for genre in genres[:1]:
    print(genre)
    print('##################################')
    save_genre_to_file(rus_genres_artists[0], SONGS_NUM_MAX, genre, 'rus', pointerCheck=False)

for genre in genres[1:2]:
    print(genre)
    print('##################################')
    save_genre_to_file(rus_genres_artists[1], SONGS_NUM_MAX, genre, 'rus', pointerCheck=False)

for genre in genres[2:len(genres)]:
    print(genre)
    print('##################################')
    save_genre_to_file(rus_genres_artists[2], SONGS_NUM_MIDDLE, genre, 'rus', pointerCheck=False)